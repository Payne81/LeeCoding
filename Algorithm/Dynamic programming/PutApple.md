# 放苹果
## 题目
把m个同样的苹果放在n个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。
## 解析
按照动态规划/递归的思路思考，需要求出其通项公式/递归公式。对于放苹果问题，通常的放一个放两个一个一个放这么想就误入歧途了.
分两种情况思考:
1.有空盘子：f(m,n)=f(m,n-1)//疑问：这不是只有一个空盘子的情况吗？那2个3个空盘子呢？这就需要递归的思想，随着一步一步的将n换成n-1你就会发现那就是2,3个空盘子的情况。

2.没有空盘子：f(m,n)=f(m-n,n)//没有空盘子，我们可以看成先给每一个盘子放一个苹果，则还剩下m-n个苹果，剩下的问题就是把这m-n个苹果放到n个盘子里的问题了，也许有人会问，m-n个苹果放到n个盘子也会出现空盘子的情况啊，不是和前面的有空盘子重复了？确实，会出现空盘子的情况，但是请注意，他们并不是真的空盘子，因为他们最开始已经放了一个，他们在这里的空代表着这个盘子只有最开始放的一个苹果。

因此：f(m,n)=f(m,n-1)+f(m-n,n) m>=n

上面的表达式并不完整，当m<n时的情况没有考虑，当m<n的时候，肯定最少有n-m个空盘子，不过幸好，这些空盘子并不影响最后的结果，因为每种方法都带有着些空盘子，剩下的问题就是把m个苹果放到m个盘子有多少种方法了。

因此：f(m,n)=f(m,m) m<n

写到这里主要表达式基本上已经写完了，但是递归都需要有结束条件，结束条件并不是很难发现，当只有一个盘子时明显只有一种方法，另外没有苹果和只有一个苹果的时候也只有一种放法。即f(m,n)=1 n=1,m=0 (或者网上一些人写m=1||n=1也是对的)

综上：

f(m,n)=1 n=1,m=0

f(m,n)=f(m,m) m<n  

f(m,n)=f(m,n-1)+f(m-n,n) m>=n

## 代码
```
#include\<iostream>
using namespace std;

int putApple(int m,int n){
   if(m\==0||n==1) return 1;
   if(n>m) 
       return putApple(m,m);
   else
        return putApple(m,n-1)+putApple(m-n,n);
}

int main(){
	int m,n;
	cin>>m>>n;
        int k = putApple(m,n);
	cout<<k<<endl;
	return 0;
}
```
